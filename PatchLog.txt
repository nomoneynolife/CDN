1.PEID 查壳
2.DIE64 看编程语言
3.OD 反编译

常用的有汇编、C、VC、VB、DELPHI、JAVA、PHTHON、易语言等等。我们遇到的需要破解的软件大多是VC、VB、DELPHI、易语言编写的，其中外挂主要是易语言编写的。

简易排行榜 1为最简单
1.有错误信息提示的软件 搜字符串插件 ps“程序有壳 一般的做法是按F9把程序运行起来，然后在代码区按CTRL+G转到00401000这个位置 在搜索字符串，有壳的程序虽然可以用这种方法来分析，找到关键位置，但是你修改代码以后无法保存，需要用Inline Patch生成器1.2打补丁 将修改后的地址与数值填写
2.找不到错误提示信息 
 2.1 当我们点登陆后，我们明明看到错误提示，但是在OD里就是搜不到
  2.1.1 内存中搜索 搜错误提示，记录第一行的地址，在数据区CTRL+G输入记录的地址，选中-右键-断点-内存访问-F9-停下后删除内存断点-F8返回上一层CALL 不同的编写语言以及作者编写代码的不同会导致返回的次数不同 找到能跳过CALL的大跳转NOP 1 CALL读取字符串 2 CALL MOV 赋值到某个地址  3 call 弹出对话框
  2.1.2 有错误信息提示的信息框。常用的方法就是在MessageBoxA这个函数上下一个断点 错误提示框 F12 暂停 AIT+K 执行到返回 
 2.2 当我们点登陆后，没有任何提示
     软件的验证流程，分为验证前、验证中、验证后，我们最常用的破解方法是根据验证后的结果来反查逆向到验证中的关键代码位置。
     假定看到过成功后弹出的功能窗口，我们是不是可以搜上面的字符串，比如窗口标题，窗口内的文字。把鼠标点一下首地址，看看信息框里有没有“本次调用来自某某地址”这样的信息，可惜，还是没有，结果这种方法也让我们空欢喜一场。别郁闷，对于这个软件，这种从成功的结果进行破解不可行，但是，这种破解思路对于其他的软件可能是个好方法，比如我们如果遇到一些软件带有“已注册”这样的关键词的重启验证的软件，你就可以尝试用这种方法破解。
	 程序在运行时怎么才能读取我们输入的账号和密码呢？通常会用操作系统提供的函数，最常用是一个函数是GetwindowsTextA取窗口内的输入文本 断点，按F8,经历了几次返回到上一层，红色箭头就是我们当前代码走到的位置，然后我们往下找可疑的跳转，5201008就是易语言编写的程序的窗口ID，将调到这里的跳转NOP掉
	 有些朋友可能要问了，这次怎么和以前不一样了，以前不是往上找跳转吗？

		我们往上找跳转的目的是想找能够跳过结果字符串的代码位置，因为我们的结果在后，所以要在结果发生前找跳转。

			现在不一样了，我们这次是在读取输入的账号和密码的位置停下来的，我们的代码位置是在验证CALL执行前，我们往上找跳转有意义吗？难道我们想找有什么跳转可以跳过读取输入的账号和密码吗？

				呵呵，真跳过了，那更是破解不了，等于没有输入账号和密码。所以，我们现在按照软件执行的验证流程继续一步步往下找，你F8往下走走，
	 
	 
	 







OD 说明
“OD分为5个区”
代码区、分析代码
信息区、了解信息
数据区、查看数据
寄存器区、查看寄存器的值，尤其是EAX
  EAX EAX寄存器 /常用作赋值 可在上一行CALL进去后 MOV EAX,1 RETN 寄存器的作用和程序的其他内存地址一样，都是用来存放数据的，区别就是寄存器在CPU里面，读取数据的速度比从内存地址里要快
  所有子程序也就是CALL的返回值都存放在EAX里面

堆栈区、查看CALL的参数、变量和返回值，以及程序调用不同的CALL的先后顺序关系
  调用的先后顺序从下往上
  堆栈区，堆栈也是内存的一部分，它的特殊之处就在于它总是和子程序（CALL）相关联，堆栈里面的地址存放的数据有三种类型，一是存放调用某个CALL下面一行代码的地址。二是存放CALL的参数。三是CALL在运行过程中的变量值。我们如果想“追码”和了解验证的“算法”，
  那么我们就需要进入验证CALL，这个时候堆栈就起了关键的提示作用了，堆栈里面会先显示出假码，因为假码是验证CALL的参数，接着出现验证CALL下面一行语句的地址，最后会显示出验证CALL里面计算出的数值，就是变量值，如果没有加密的话，就会显示出计算出来的真码。

CTRL+F9 当我们发现此刻程序停留在系统领空以后，我们就赶快按CTRL+F9执行到系统函数的结尾处，因为你花时间看系统函数内部的代码完全是浪费时间
ALT+F9  当程序暂停在系统领空的时候，你按一下ALT+F9,程序就一下子就执行完当前系统领空的代码回到了程序领空。经常用的手法就是在诸如MessageBoxA这样的操作系统提供的函数下断点，程序断下来后，就按一下ALT+F9从系统领空返回到程序领空，再分析代码。提醒一下，如果是MessageBoxA函数，你按完ALT+F9后你会发现并没有返回到程序领空，怎么回事？很简单，你需要把错误提示信息框关闭，然后程序就自动返回到程序领空了，因为错误信息框在等待用户操作，你不操作，程序就一直停留在等待操作的状态中。




CALL 子程序入口
JNZ 条件跳转
JMP 无条件跳转


第一类是传送数据的指令，比如MOV、LEA、PUSH、POP等

第二类汇编指令是比较判断指令
  CMP EAX,0 比较EAX和零是否相等？影响下一个判断
  TEST EBX,EBX 这句代码的意思是判断EBX的值是否为零？

第三类指令是运算指令，比如ADD就是两个数值相加，SUB就是两个数值相减，还有乘法、除法等等

“重启验证”
你第一次打开软件时需要手工输入账号和密码，然后点击登录，这个时候软件除了执行验证流程以外，还会执行一个操作，
就是把你输入的账号和密码自动保存在你的电脑里的一个位置，这样一来，等你下次再打开时，软件会自动读取上次保存的账号和密码，
然后自动执行判断，如果正确，就提示“已注册”，如果错误，就提示“未注册”，这就是重启验证，你也可以把这样的软件叫做“自动验证”。
我们在深入一下，软件会把我们输入的账号和密码保存在哪里呢？基本上就两个地方可以藏身，
一个是注册表里面，一个是新创建的一个文件里，这个文件有可能是TXT格式 ，也有可能是INI格式的，还有可能是其他类型的。
知道账号和密码存在哪里对于破解有什么用处呢？非常重要，及其关键，因为对于不同的存放位置，程序在读取账号和密码时会使用不同的命令，
比如注册表，会用RegOpenKeyA等；比如TXT，会用ReadFile；比如INI，会用GetPrivateProfileString；